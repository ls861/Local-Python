
# =============================================================================
# Delta MS colour coded by MS probability
# =============================================================================

def deltaMS_probability(ADx_subset, medians, normalisation, figuresize, fontsize_axes, string_mass, string_deltaMS, string_prob_ratio, save):

    import numpy as np
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    from scipy.stats import norm
    import pickle

    # =============================================================================
    # colour code based upon median value of converged chain (mass and sfr) (also using same outlier params as before)
    # =============================================================================

    filename = 'lm_chain_scenario_34_clusters_z1p25-6p0_4x20000_24_005.p'
    with open('/Users/lester/Documents/linmix_files/mass_sfr_z_chains/medians_{}'.format(filename), 'rb') as f:
        med = pickle.load(f, encoding='latin1')

    # sfr_surface_real = ((medians['beta_a']+ADx_subset['redshift_BEAGLE']*medians['beta_b'])*ADx_subset['mass_BEAGLE_stellar'])+(np.log10(medians['alphaN_a']*((1+ADx_subset['redshift_BEAGLE'])**medians['alphaN_b'])))+normalisation-9.0-(normalisation*(medians['beta_a']+ADx_subset['redshift_BEAGLE']*medians['beta_b'])) # OLD
    # sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*ADx_subset['redshift_BEAGLE'])*(ADx_subset['mass_BEAGLE_stellar']-normalisation)) + (np.log10(medians['alphaN_a']*((1.0+ADx_subset['redshift_BEAGLE'])**medians['alphaN_b']))) + normalisation - 9.0 # error if alphaN_a <0
    # sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*ADx_subset['redshift_BEAGLE'])*(ADx_subset['mass_BEAGLE_stellar']-normalisation)) + (medians['alphaN_a'] + medians['alphaN_b']*ADx_subset['redshift_BEAGLE']) # error if alphaN_a <0

    # COLOUR CODED BY MEDIAN
    # sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*ADx_subset['redshift_BEAGLE'])*(ADx_subset['mass_BEAGLE_stellar']-normalisation)) + medians['alphaN_a'] + medians['alphaN_b']*np.log10(1.0+ADx_subset['redshift_BEAGLE']) + normalisation - 9.0 # new alphaN_a = old np.log10(alphaN_a)
    # log_p_xi_eta_theta = norm.logpdf(ADx_subset['sfr_BEAGLE_instant'], scale=medians['sig0'], loc=sfr_surface_real)
    # log_p_eta_xi_theta = norm.logpdf(ADx_subset['sfr_BEAGLE_instant'], scale=medians['sig0'], loc=sfr_surface_real)
    # p_bad = norm.pdf(ADx_subset['sfr_BEAGLE_instant'], scale=medians['outlier_sigma'], loc=medians['outlier_mean'])

    # COLOUR CODED BY CONVERGED VALUE
    sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*np.array(med['zeta']))*(np.array(med['xi'])-normalisation)) + medians['alphaN_a'] + medians['alphaN_b']*np.log10(1.0+np.array(med['zeta'])) + normalisation - 9.0 # new alphaN_a = old np.log10(alphaN_a)
    log_p_xi_eta_theta = norm.logpdf(med['eta'], scale=medians['sig0'], loc=sfr_surface_real)
    log_p_eta_xi_theta = norm.logpdf(med['eta'], scale=medians['sig0'], loc=sfr_surface_real)
    p_bad = norm.pdf(med['eta'], scale=medians['outlier_sigma'], loc=medians['outlier_mean'])

    z_bad = medians['pbad']*p_bad
    z_good = (1-medians['pbad'])*np.exp(log_p_eta_xi_theta)

    idx_sort = np.argsort(z_good/z_bad)

    fig = plt.figure(figsize=(figuresize, figuresize))
    ax1 = fig.add_axes([0, 0, 0.85, 0.84]) #[left, bottom, width, height]

    scatter = ax1.scatter(ADx_subset['mass_BEAGLE_stellar'][idx_sort], (ADx_subset['sfr_BEAGLE_instant']-sfr_surface_real)[idx_sort], c=np.log10((z_good/z_bad)[idx_sort]), cmap=mpl.cm.get_cmap('coolwarm'), alpha=1.0, vmin=-2.5, vmax=2.5)

    ax1.scatter(ADx_subset['mass_BEAGLE_stellar'][idx_sort][ADx_subset['redshift_BEAGLE'][idx_sort]>4], (ADx_subset['sfr_BEAGLE_instant']-sfr_surface_real)[idx_sort][ADx_subset['redshift_BEAGLE'][idx_sort]>4], c=5+np.log10((z_good/z_bad)[idx_sort][ADx_subset['redshift_BEAGLE'][idx_sort]>4]), cmap=mpl.cm.get_cmap('coolwarm'), alpha=1.0, vmin=-2.5, vmax=2.5)




    x_tmp = np.array((0, 20))
    ax1.plot(x_tmp, x_tmp*0, color='k', alpha=1.0, lw=3)
    ax1.plot(x_tmp, (x_tmp*0)+medians['sig0'], color='k', alpha=1.0, linestyle='dashed', lw=3)
    ax1.plot(x_tmp, (x_tmp*0)-medians['sig0'], color='k', alpha=1.0, linestyle='dashed', lw=3)

    ax1.set_xlim(6.5, 10.5)
    ax1.set_xlabel(string_mass, labelpad=10)
    ax1.xaxis.set_major_locator(mpl.ticker.MultipleLocator(1))
    ax1.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.5))
    ax1.xaxis.set_tick_params(which='major', size=10, width=2, direction='in', bottom='on', top='on')
    ax1.xaxis.set_tick_params(which='minor', size=5, width=2, direction='in', bottom='on', top='on')
    ax1.xaxis.set_tick_params(labelsize=fontsize_axes)

    ax1.set_ylim(-2.5, 2.5)
    ax1.set_ylabel(string_deltaMS, labelpad=10)
    ax1.yaxis.set_major_locator(mpl.ticker.MultipleLocator(1))
    ax1.yaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.5))
    ax1.yaxis.set_tick_params(which='major', size=10, width=2, direction='in', left='on', right='on')
    ax1.yaxis.set_tick_params(which='minor', size=5, width=2, direction='in', left='on', right='on')
    ax1.yaxis.set_tick_params(labelsize=fontsize_axes)

    #ax1.legend(bbox_to_anchor=(1, 1), loc=1, frameon=False, fontsize=fontsize_legend)

    cbaxes = fig.add_axes([0.85, 0, 0.05, 0.84]) #[left, bottom, width, height]
    cb = plt.colorbar(scatter, cax = cbaxes)

    cb.set_ticks(np.linspace(-2, 2, 5))
    #cb.set_ticklabels(['', 1, 2, 3, 4, 5, 6, ''])
    cb.set_label(string_prob_ratio, rotation=270, labelpad=30)
    cb.ax.tick_params(axis='y', size=5, width=2, direction='in', labelsize=fontsize_axes)

    if save:
        plt.savefig('deltaMS_probability.png', dpi=300, transparent=False, bbox_inches='tight')
    plt.show()
