def redshift_bins_MS(chain_MS_29_c1, redshift, z_lower, z_upper, normalisation, figuresize, fontsize_legend, fontsize_axes, string_mass, string_sfr, string_prob_ratio, legend, save):

    # Import required packages
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import numpy as np
    from pylab import cm
    from scipy.stats import norm
    from astropy.io import fits
    from scipy.optimize import curve_fit
    import pickle

    def get_medians(chain_MS):
    #    names = chain_original.dtype.names
        names = ['alphaN_a', 'alphaN_b', 'beta_a', 'beta_b', 'sig0', 'k', 'pbad', 'outlier_mean', 'outlier_sigma']
        dic = {}
        for name in names:
            dic[name] = np.median(chain_MS[name])
        return dic

    i = redshift - 1

    medians = get_medians(chain_MS_29_c1)

    # =============================================================================
    # get files
    # =============================================================================

    fileName = '/Users/lester/Documents/GitHub/Local-Python/Year2/Project1/BEAGLE_dust_install/from_cluster/summary_catalogues/cluster_summary_file_w_int_sfr.fits'
    summary = fits.open(fileName)
    # print(summary.info())
    # print(summary[1].header)
    # print(summary[1].data['field_AD_1'])

    fileName = '/Users/lester/Documents/GitHub/Local-Python/Year2/Project1/BEAGLE_dust_install/analysis/kelly_input/s31z{}_with_s33_and_summary_cat.fits'.format(redshift)
    sc = fits.open(fileName)
    # print(sc.info())
    # print(sc[1].header)
    # print(sc[1].data['field_AD_1'])

    sc = sc[1].data
    # print(sc['uidb'])

    # =============================================================================
    # outlier prob
    # =============================================================================

    # sfr_surface_real = ((medians['beta_a']+sc['redshift_BEAGLE_1']*medians['beta_b'])*sc['mass_BEAGLE_stellar_1'])+(np.log10(medians['alphaN_a']*((1+sc['redshift_BEAGLE_1'])**medians['alphaN_b'])))+normalisation-9.0-(normalisation*(medians['beta_a']+sc['redshift_BEAGLE_1']*medians['beta_b']))


    idx_keep1 = sc['field_AD_2_1'] > -1

    # =============================================================================
    # colour code based upon median value of converged chain (mass and sfr) (also using same outlier params as before)
    # =============================================================================

    # not trivial

    filenames = ['lm_chain_scenario_33_clusters_z1p25-2p0_4x20000_26_005.p',
             'lm_chain_scenario_33_clusters_z2p0-3p0_4x20000_26_005.p',
             'lm_chain_scenario_33_clusters_z3p0-4p0_4x20000_26_005.p',
             'lm_chain_scenario_33_clusters_z4p0-5p0_4x20000_26_005.p',
             'lm_chain_scenario_33_clusters_z5p0-6p0_4x20000_26_005.p']

    filename = filenames[i]
    with open('/Users/lester/Documents/linmix_files/mass_sfr_z_chains/medians_{}'.format(filename), 'rb') as f:
        med = pickle.load(f, encoding='latin1')

    # plt.scatter(sc['mass_BEAGLE_stellar_1'], sc['sfr_BEAGLE_instant_1'])
    # plt.scatter(med['xi'], med['eta'])
    # plt.show()
    #
    # print(len(med['xi']), len(sc['mass_BEAGLE_stellar_1']), len(sc['mass_BEAGLE_stellar_1'][idx_keep1]))
    #
    # plt.scatter(med['xi'], sc['mass_BEAGLE_stellar_1'][idx_keep1])
    # plt.plot((min(med['xi']), max(med['xi'])),(min(med['xi']), max(med['xi'])), c='k')
    # plt.show()
    #
    # plt.scatter(med['eta'], sc['sfr_BEAGLE_instant_1'][idx_keep1])
    # plt.plot((min(med['eta']), max(med['eta'])),(min(med['eta']), max(med['eta'])), c='k')
    # plt.show()
    #
    # plt.scatter(med['zeta'], sc['redshift_BEAGLE_1'][idx_keep1])
    # plt.plot((min(med['zeta']), max(med['zeta'])),(min(med['zeta']), max(med['zeta'])), c='k')
    # plt.show()

    ########





    ### linear
    #sfr_surface_real = ((medians['beta_a']+s['redshift_BEAGLE']*medians['beta_b'])*(s['mass_BEAGLE_stellar'] - 9.7))  + \
    #                    (medians['alphaN_a']+s['redshift_BEAGLE']*medians['alphaN_b'])




    # COLOUR CODED BY MEDIAN
    # sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*sc['redshift_BEAGLE_1'])*(sc['mass_BEAGLE_stellar_1']-normalisation)) + (medians['alphaN_a'] + medians['alphaN_b']*sc['redshift_BEAGLE_1'])
    # log_p_xi_eta_theta = norm.logpdf(sc['sfr_BEAGLE_instant_1'][idx_keep1], scale=medians['sig0'], loc=sfr_surface_real[idx_keep1])
    # log_p_eta_xi_theta = norm.logpdf(sc['sfr_BEAGLE_instant_1'][idx_keep1], scale=medians['sig0'], loc=sfr_surface_real[idx_keep1])
    # p_bad = norm.pdf(sc['sfr_BEAGLE_instant_1'][idx_keep1], scale=medians['outlier_sigma'], loc=medians['outlier_mean'])

    # COLOUR CODED BY CONVERGED VALUE
    sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*np.array(med['zeta']))*(np.array(med['xi'])-normalisation)) + (medians['alphaN_a'] + medians['alphaN_b']*np.array(med['zeta']))
    log_p_xi_eta_theta = norm.logpdf(med['eta'], scale=medians['sig0'], loc=sfr_surface_real)
    log_p_eta_xi_theta = norm.logpdf(med['eta'], scale=medians['sig0'], loc=sfr_surface_real)
    p_bad = norm.pdf(med['eta'], scale=medians['outlier_sigma'], loc=medians['outlier_mean'])

    # this is idx_keep1 subset, because when swapping to converged values, I only have subset sized array
    z_bad = medians['pbad']*p_bad
    z_good = (1.0-medians['pbad'])*np.exp(log_p_eta_xi_theta)






    # =============================================================================
    # mass and sfr with errors
    # =============================================================================


    # idx_keep = sc['field_AD_2_1'][idx_sort] > -1


    mass = sc['mass_BEAGLE_stellar_1']
    massm = (sc['mass_BEAGLE_stellar_1']-(np.log10(sc['M_star_68.00'][:,0])-sc['mag_AD_1']))
    massp = ((np.log10(sc['M_star_68.00'][:,1])-sc['mag_AD_1'])-sc['mass_BEAGLE_stellar_1'])

    sfr = sc['sfr_BEAGLE_instant_1']
    sfrm = (sc['sfr_BEAGLE_instant_1']-(np.squeeze(sc['log_instant_sfr_median_68_00'])[:,0]-sc['mag_AD_1']))
    sfrp = ((np.squeeze(sc['log_instant_sfr_median_68_00'])[:,1]-sc['mag_AD_1'])-sc['sfr_BEAGLE_instant_1'])




    # =============================================================================
    # 3 sigma clipping
    # =============================================================================

    def straight_line(x, A, B): # this is your 'straight line' y=f(x)
        return B*(x-9.7) + A

    xi_sampled = mass
    eta_sampled = sfr
    id_sampled = np.arange(len(xi_sampled))

    outliers = 1

    xi_outliers = []
    eta_outliers = []
    id_outliers = []

    count = 0

    while outliers > 0:

        popt, pcov = curve_fit(straight_line, xi_sampled, eta_sampled)
        beta = popt[1]
        alphaN = popt[0]

        # list of sfrs according to input values
        eta_from_relation = beta*(xi_sampled-9.7) + alphaN
        eta_residuals = eta_sampled - eta_from_relation
        eta_sigma = np.std(eta_residuals)
        eta_idx = (abs(eta_residuals)<3.0*eta_sigma)


        count+=1
    #     print(count, len(xi_outliers))
    #     plt.scatter(xi_sampled, eta_sampled)
    #     plt.scatter(xi_outliers, eta_outliers)
    #         # plt.scatter(self.xi[self.id_outliers_below], self.eta[self.id_outliers_below], color='lime', marker='x', s=100)
    #     plt.plot((5.0, 11.0), (beta*(5.0-9.7) + alphaN, beta*(11.0-9.7) + alphaN))
    # #            plt.plot((5.0, 11.0), (outlier_mean, outlier_mean))
    #     plt.show()


        outliers = sum(~eta_idx)

        for oo in range(outliers):
            xi_outliers.append(xi_sampled[~eta_idx][oo])
            eta_outliers.append(eta_sampled[~eta_idx][oo])
            id_outliers.append(id_sampled[~eta_idx][oo])

        xi_sampled = xi_sampled[eta_idx]
        eta_sampled = eta_sampled[eta_idx]
        id_sampled = id_sampled[eta_idx]

    id_outliers = np.array(id_outliers)
    idx_sigoutlier = np.full(len(mass), False)


    if len(id_outliers!=0):
        idx_sigoutlier[id_outliers] = True



    # idx_sigoutlier = 1 if OUTLIER
    # idx_keep1 = 1 if KEPT


    idx_k1_c0 = idx_keep1 & ~idx_sigoutlier # kept and not sigma clipped (coloured circles)
    idx_k1_c1 = idx_keep1 & idx_sigoutlier # kept and sigma clipped (coloured stars)
    idx_k0_c0 = ~idx_keep1 & ~idx_sigoutlier # not kept, sigma clipped (green circles)
    idx_k0_c1 = ~idx_keep1 & idx_sigoutlier # not kept, not sigma clipped (green stars)

    # need to make the coloured ones a subset array
    idx_k1_c0 = idx_k1_c0[idx_keep1]
    idx_k1_c1 = idx_k1_c1[idx_keep1]

    # =============================================================================
    # THE PLOT
    # =============================================================================


    fig = plt.figure(figsize=(figuresize, figuresize))
    ax1 = fig.add_axes([0, 0, 0.85, 0.84]) #[left, bottom, width, height]


    idx_sort = np.argsort(np.log10((z_good/z_bad)[idx_k1_c0]))
    scatter = ax1.scatter(mass[idx_keep1][idx_k1_c0][idx_sort], sfr[idx_keep1][idx_k1_c0][idx_sort], c=np.log10((z_good/z_bad)[idx_k1_c0])[idx_sort], cmap=mpl.cm.get_cmap('coolwarm'), alpha=1.0, vmin=-2.5, vmax=2.5, zorder=1)

    idx_sort = np.argsort(np.log10((z_good/z_bad)[idx_k1_c1]))
    ax1.scatter(mass[idx_keep1][idx_k1_c1][idx_sort], sfr[idx_keep1][idx_k1_c1][idx_sort], c=np.log10((z_good/z_bad)[idx_k1_c1])[idx_sort], cmap=mpl.cm.get_cmap('coolwarm'), alpha=1.0, vmin=-2.5, vmax=2.5, zorder=1, s=150, marker='*')

    ax1.scatter(mass[idx_k0_c0], sfr[idx_k0_c0], color='green')
    ax1.scatter(mass[idx_k0_c1], sfr[idx_k0_c1], color='green', s=150, marker='*')

    # for legend only , label='Included in all scenarios'
    cmap = mpl.cm.get_cmap('coolwarm')
    ax1.scatter([],[], color=cmap(0), alpha=1.0, label='Included in all scenarios')
    # ax1.scatter([],[], c=cmap(0), alpha=1.0, s=150, marker='*', label='Sigma clipped')
    ax1.scatter([],[], color='green', alpha=1.0, label='Removed for all scenarios')
    ax1.scatter([],[], color='w', edgecolors='k', alpha=1.0, s=150, marker='*', label='Sigma clipped')

    ax1.errorbar(mass[idx_keep1], sfr[idx_keep1], xerr=[massm[idx_keep1], massp[idx_keep1]], yerr=[sfrm[idx_keep1], sfrp[idx_keep1]], linestyle='', c='black', zorder=0, lw=0.5, mew=0)
    ax1.errorbar(mass[~idx_keep1], sfr[~idx_keep1], xerr=[massm[~idx_keep1], massp[~idx_keep1]], yerr=[sfrm[~idx_keep1], sfrp[~idx_keep1]], linestyle='', c='green', zorder=0, lw=0.5, mew=0)

    # MS LINE
    x_tmp = np.array([6.5, 10.5])
    # ax1.plot(x_tmp, medians['beta_a']*(x_tmp-normalisation) + medians['alphaN_a'], c='red', linestyle='dashed')


    # =============================================================================
    # OUTLIER VIOLIN
    # =============================================================================

    import scipy.stats as stats

    mu = medians['outlier_mean']
    sigma = medians['outlier_sigma']
    x = np.linspace(-10, 10, 1000)
    x1sig = np.linspace(mu-sigma, mu+sigma, 1000)
    y = stats.norm.pdf(x, mu, sigma)
    y1sig = stats.norm.pdf(x1sig, mu, sigma)
    # plt.plot(x, stats.norm.pdf(x, mu, sigma))
    # ax1.fill_betweenx(x, -(y/(4*max(y)))+10, (y/(4*max(y)))+10, color='grey', alpha=0.3, lw=0.3)
    ax1.fill_betweenx(x, 0, (y/(2*max(y)))+6.5, color='grey', alpha=0.3, lw=0.3)
    ax1.fill_betweenx(x1sig, 0, (y1sig/(2*max(y1sig)))+6.5, color='grey', alpha=0.3, lw=0.3)
    # plt.xlim(0, 1.1*max(y))
    # plt.ylim(mu - 3*sigma, mu + 3*sigma)
    # plt.show()


    # =============================================================================
    # BASICS
    # =============================================================================

    ax1.set_xlim(6.5, 10.5)
    ax1.set_xlabel(string_mass, labelpad=10)
    ax1.xaxis.set_major_locator(mpl.ticker.MultipleLocator(1))
    ax1.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.5))
    ax1.xaxis.set_tick_params(which='major', size=10, width=2, direction='in', bottom='on', top='on')
    ax1.xaxis.set_tick_params(which='minor', size=5, width=2, direction='in', bottom='on', top='on')
    ax1.xaxis.set_tick_params(labelsize=fontsize_axes)

    ax1.set_ylim(-3.5, 3.5)
    ax1.set_ylabel(string_sfr, labelpad=10)
    ax1.yaxis.set_major_locator(mpl.ticker.MultipleLocator(1))
    ax1.yaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.5))
    ax1.yaxis.set_tick_params(which='major', size=10, width=2, direction='in', left='on', right='on')
    ax1.yaxis.set_tick_params(which='minor', size=5, width=2, direction='in', left='on', right='on')
    ax1.yaxis.set_tick_params(labelsize=fontsize_axes)

    ax1.text(6.7, 2.8, r'{} $<$ z $<$ {}'.format(str(z_lower), str(z_upper)))

    if legend:
        ax1.legend(bbox_to_anchor=(0.95, 0.25), frameon=True, fontsize=fontsize_legend, facecolor='w', framealpha=1)



    cbaxes = fig.add_axes([0.85, 0, 0.05, 0.84]) #[left, bottom, width, height]
    cb = plt.colorbar(scatter, cax = cbaxes)

    cb.set_ticks(np.linspace(-2, 2, 5))
    #cb.set_ticklabels(['', 1, 2, 3, 4, 5, 6, ''])
    cb.set_label(string_prob_ratio, rotation=270, labelpad=30)
    cb.ax.tick_params(axis='y', size=5, width=2, direction='in', labelsize=fontsize_axes)


    if save:
        plt.savefig('redshift_bins_MS_{}.png'.format(str(redshift)), dpi=300, transparent=False, bbox_inches='tight')
    plt.show()
