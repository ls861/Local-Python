
# =============================================================================
# mass dependent scatter heatplot 1.25<z<2.0
# =============================================================================

def heatplot_scatter(s, medians, normalisation, figuresize, fontsize_axes, string_mass, string_sfr, save):
    
    import numpy as np
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import matplotlib.colors as mcolors
    from pylab import cm
    
    num = 3
    z_med_hp_low = 1.25
    z_med_hp_high = 2.0
    hp_lower_masses = [0.0]
    
    z_med_hp = (z_med_hp_low+z_med_hp_high)/2.0
    z_med_hp_gap = (z_med_hp_low+z_med_hp_high)/2.0 - z_med_hp_low
    santini_idx = 1 # 1.3 to 2.0
    
    for m in range(len(hp_lower_masses)):
        
        idx_rdm = np.arange(len(s))[(s['redshift_BEAGLE']>z_med_hp_low)&(s['redshift_BEAGLE']<z_med_hp_high)&(s['mass_BEAGLE_stellar']+s['mag_AD']>hp_lower_masses[m])] 
        # print(len(idx_rdm))
    
        x_hp = np.array([])
        y_hp = np.array([])
        z_hp = np.array([])
        
        n_hp = 300 # number of samples to take from GMM in total
        
        for i in idx_rdm:
    
            for G in range(3):
                
                mean = np.array([s['x_GMM_3d'][i,G],s['y_GMM_3d'][i,G],s['z_GMM_3d'][i,G]])
                cov = np.array([[np.power(s['xsig_GMM_3d'][i,G],2), s['xycov_GMM_3d'][i,G], s['xzcov_GMM_3d'][i,G]],[s['xycov_GMM_3d'][i,G], np.power(s['ysig_GMM_3d'][i,G],2), s['yzcov_GMM_3d'][i,G]],[s['xzcov_GMM_3d'][i,G], s['yzcov_GMM_3d'][i,G], np.power(s['zsig_GMM_3d'][i,G],2)]])
        
                xyz = np.random.multivariate_normal(mean, cov, size=int(n_hp*s['amp_GMM_3d'][i,G]))
        
                x_hp = np.concatenate((x_hp,xyz[:,0]))
                y_hp = np.concatenate((y_hp,xyz[:,1]))
                z_hp = np.concatenate((z_hp,xyz[:,2]))
    
        # only keep GMM samples within the redshift bin
        x_hp = x_hp[abs(z_hp - z_med_hp) < z_med_hp_gap]
        y_hp = y_hp[abs(z_hp - z_med_hp) < z_med_hp_gap]
        z_hp = z_hp[abs(z_hp - z_med_hp) < z_med_hp_gap]
    
        fig = plt.figure(figsize=(0.7*figuresize, 0.7*figuresize))
        
        ax1 = fig.add_axes([0, 0, 0.85, 0.84]) #[left, bottom, width, height]
    #    ax1.set_title('{} - {}'.format(z_med_hp_low, z_med_hp_high))
        
        xlow = 5.5
        xhigh = 11.5
        ylow = -3.5
        yhigh = 3.5
        
        ximin = 8.5
        ximax = 10.0
        
    
        
        h = ax1.hist2d(x_hp, y_hp, bins=50, range=((xlow, xhigh),(ylow, yhigh)), norm=mcolors.LogNorm(), cmap=plt.cm.viridis)
    #    ax1.plot((xlow,xhigh), (alpha_san[santini_idx-1] + beta_san[santini_idx-1]*xlow,alpha_san[santini_idx-1] + beta_san[santini_idx-1]*xhigh), color='w') # santini
        ax1.plot((9.7,9.7), (ylow, yhigh), color='w')
    
        x_tmp = np.array((xlow, xhigh))
    
    
        # sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*z_med_hp)*(x_tmp-normalisation)) + (np.log10(medians['alphaN_a']*((1.0+z_med_hp)**medians['alphaN_b']))) + normalisation - 9.0 # error if alphaN_a <0
        sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*z_med_hp)*(x_tmp-normalisation)) + (medians['alphaN_a'] + medians['alphaN_b']*z_med_hp) # error if alphaN_a <0
        # sfr_surface_real = ((medians['beta_a'] + medians['beta_b']*z_med_hp)*(x_tmp-normalisation)) + medians['alphaN_a'] + medians['alphaN_b']*np.log10(1.0+z_med_hp) + normalisation - 9.0 # new alphaN_a = old np.log10(alphaN_a)
    
        ax1.plot(x_tmp, sfr_surface_real, color='r')
    
        sig_tmp = medians['sig0']*(((1.0-medians['k'])*(x_tmp-ximax)/(ximax-ximin))+1.0)    
        ax1.plot(x_tmp, sfr_surface_real + sig_tmp, color='r', linestyle='dashed')
        ax1.plot(x_tmp, sfr_surface_real - sig_tmp, color='r', linestyle='dashed')
    
    #8.5 and 10
        ax1.set_xlim(xlow, xhigh)
        ax1.set_xlabel(string_mass, labelpad=10)
        ax1.xaxis.set_major_locator(mpl.ticker.MultipleLocator(1))
        ax1.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.5))
        ax1.xaxis.set_tick_params(which='major', size=10, width=2, direction='in', bottom='on', top='on')
        ax1.xaxis.set_tick_params(which='minor', size=5, width=2, direction='in', bottom='on', top='on')
        ax1.xaxis.set_tick_params(labelsize=fontsize_axes)
        
        ax1.set_ylim(ylow, yhigh)
        ax1.set_ylabel(string_sfr, labelpad=10)
        ax1.yaxis.set_major_locator(mpl.ticker.MultipleLocator(1))
        ax1.yaxis.set_minor_locator(mpl.ticker.MultipleLocator(0.5))
        ax1.yaxis.set_tick_params(which='major', size=10, width=2, direction='in', left='on', right='on')
        ax1.yaxis.set_tick_params(which='minor', size=5, width=2, direction='in', left='on', right='on')
        ax1.yaxis.set_tick_params(labelsize=fontsize_axes)
        
        cbaxes = fig.add_axes([0.85, 0, 0.05, 0.84]) #[left, bottom, width, height]
        cb = plt.colorbar(h[3], cax=cbaxes)
        cb.set_ticks([3, 5, 10, 20])
        cb.set_ticklabels([3, 5, 10, 20])
        #cbaxes.set_ylabel(r'TEST', rotation=270, labelpad=30)
        #cbaxes.yaxis.set_major_locator(mpl.ticker.LogLocator(base=10, numticks=1))
        cbaxes.yaxis.set_tick_params(which='major', size=10, width=2, direction='in', right='on')
        cbaxes.yaxis.set_tick_params(which='minor', size=0)
        cbaxes.yaxis.set_tick_params(labelsize=fontsize_axes)
        
        cmap = cm.get_cmap('viridis')
        rgba = cmap(0)
        ax1.set_facecolor(rgba)
        
    #    ax1.legend(bbox_to_anchor=(1, 1), loc=1, frameon=False, fontsize=fontsize_legend)
        
        if save:
            plt.savefig('heatplot_scatter.png', dpi=300, transparent=False, bbox_inches='tight')
        plt.show()
